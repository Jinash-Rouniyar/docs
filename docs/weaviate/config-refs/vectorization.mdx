---
title: Vectorization
description: Reference for configuring vectorizers and named vectors in Weaviate.
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import FilteredTextBlock from "@site/src/components/Documentation/FilteredTextBlock";
import PyCode from "!!raw-loader!/_includes/code/config-refs/reference.collections.py";
import TSCode from "!!raw-loader!/_includes/code/howto/manage-data.collections.ts";
import JavaCode from "!!raw-loader!/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.classes.java";
import JavaReplicationCode from "!!raw-loader!/_includes/code/howto/java/src/test/java/io/weaviate/docs/manage-data.replication.java";
import GoCode from "!!raw-loader!/_includes/code/howto/go/docs/manage-data.classes_test.go";

**Vectorization** is the process of converting data into numerical vector embeddings. Weaviate can automate this process using vectorizer modules. This page covers how to configure the vectorizer and manage vector embeddings for a collection.

## Single vector collections

If you don't explicitly define a [named vector](#named-vectors) in your collection definition, Weaviate automatically creates what's known as a _single vector_ collection. These vectors are stored internally under the named vector `default` (which is a reserved vector name).

To learn which properties of your data are vectorized, refer to the [Configure semantic indexing](./indexing/vector-index.mdx#configure-semantic-indexing) section.

#### Code example 

This code example shows how to configure the vectorizer parameters through a client library:

<Tabs groupId="languages">
  <TabItem value="py" label="Python Client v4">
    <FilteredTextBlock
      text={PyCode}
      startMarker="# START Vectorizer"
      endMarker="# END Vectorizer"
      language="py"
    />
  </TabItem>
  <TabItem value="js" label="JS/TS Client v3">
    <FilteredTextBlock
      text={TSCode}
      startMarker="// START Vectorizer"
      endMarker="// END Vectorizer"
      language="ts"
    />
  </TabItem>
  <TabItem value="java" label="Java">
    <FilteredTextBlock
      text={JavaCode}
      startMarker="// START CreateCollectionWithVectorizer"
      endMarker="// END CreateCollectionWithVectorizer"
      language="java"
    />
  </TabItem>
  <TabItem value="go" label="Go">
    <FilteredTextBlock
      text={GoCode}
      startMarker="// START CreateCollectionWithVectorizer"
      endMarker="// END CreateCollectionWithVectorizer"
      language="gonew"
    />
  </TabItem>
</Tabs>

:::tip Further resources

For more code example and configuration guides visit the [How-to: Vectorizer and vector index config](../manage-collections/index.mdx) guide.

:::

## Multiple vector embeddings (named vectors) {#named-vectors}

import MultiVectorSupport from "/_includes/multi-vector-support.mdx";

<MultiVectorSupport />

[comment]: # " This section is duplicated, with a link to this page, in: multi-vector-support dot mdx "

Collections can have multiple named vectors.

The vectors in a collection can have their own configurations. Each vector space can set its own index, its own compression algorithm, and its own vectorizer. This means you can use different vectorization models, and apply different distance metrics, to the same object.

To work with named vectors, adjust your queries to specify a target vector for [vector search](/weaviate/search/similarity#named-vectors) or [hybrid search](/weaviate/search/hybrid#named-vectors) queries.

#### Code example 

This code example shows how to configure multiple named vectors through a client library:

<Tabs groupId="languages">
  <TabItem value="py" label="Python Client v4">
    <FilteredTextBlock
      text={PyCode}
      startMarker="# START MultipleVectors"
      endMarker="# END MultipleVectors"
      language="py"
    />
  </TabItem>
  <TabItem value="js" label="JS/TS Client v3">
    <FilteredTextBlock
      text={TSCode}
      startMarker="// START BasicNamedVectors"
      endMarker="// END BasicNamedVectors"
      language="ts"
    />
  </TabItem>
  <TabItem value="java" label="Java">
    <FilteredTextBlock
      text={JavaCode}
      startMarker="// START CreateCollectionWithNamedVectors"
      endMarker="// END CreateCollectionWithNamedVectors"
      language="java"
    />
  </TabItem>
  <TabItem value="go" label="Go">
    <FilteredTextBlock
      text={GoCode}
      startMarker="// START CreateCollectionWithNamedVectors"
      endMarker="// END CreateCollectionWithNamedVectors"
      language="gonew"
    />
  </TabItem>
</Tabs>

:::tip Further resources

For more code example and configuration guides visit the [How-to: Vectorizer and vector index config](../manage-collections/index.mdx) guide.

:::

### Query a named vector

To do a vector search on a collection with named vectors, specify the vector space to search.

Use named vectors with [vector similarity searches](/weaviate/search/similarity#named-vectors) (`near_text`, `near_object`, `near_vector`, `near_image`) and [hybrid search](/weaviate/search/hybrid#named-vectors).

Named vector collections support hybrid search, but only for one vector at a time.

[Keyword search](/weaviate/search/bm25) syntax does not change if a collection has named vectors.

### Query multiple named vectors

:::info Added in `v1.26`
:::

Where multiple named vectors are defined in a collection, you can query them in a single search. This is useful for comparing the similarity of an object to multiple named vectors.

This is called a "multi-target vector search".

In a multi-target vector search, you can specify:

- The target vectors to search
- The query(ies) to compare to the target vectors
- The weights to apply to each distance (raw, or normalized) for each target vector

Read more in [How-to: Multi-target vector search](../search/multi-vector.md).

### Adding a named vector after collection creation

:::info Added in `v1.31`
:::

A named vector can be added to an existing collection definition after collection creation. This allows you to add new vector representations for objects without having to delete and recreate the collection.

When you add a new named vector to an existing collection definition, it's important to understand that **existing objects' new named vector will remain unpopulated**. Only objects created or updated after the named vector addition will receive these new vector embeddings.

This prevents any unintended side effects, such as incurring large vectorization time or costs for all existing objects in a collection.

If you want to populate the new named vector for existing objects, update the object with the existing object UUID and vectors. This will trigger the vectorization process for the new named vector.

<!-- TODO: I wonder we should show an example - maybe once the vectorizer syntax is updated with 1.32 -->

:::caution Not available for legacy (unnamed) vectorizers
The ability to add a named vector after collection creation is only available for collections configured with named vectors.
:::

### Default distance metric

Weaviate allows you to configure the `DEFAULT_VECTOR_DISTANCE_METRIC` which will be applied to every collection unless overridden individually. You can choose from: `cosine` (default), `dot`, `l2-squared`, `manhattan`, `hamming`.

## Related pages

- [How-to: Manage collections](../manage-collections/vector-config.mdx#define-named-vectors): Configure vectors in collections
- [How-to: Search](../search/index.mdx): Code examples for search
- [Weaviate academy: Named vectors](../../academy/py/named_vectors/index.md)

## Questions and feedback

import DocsFeedback from "/_includes/docs-feedback.mdx";

<DocsFeedback />
