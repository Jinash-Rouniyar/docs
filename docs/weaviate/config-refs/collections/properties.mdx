---
title: Properties
description: Reference for collection property parameters.
---

**Properties** define the data structure of the objects within your collection. Each property is an object within the `properties` array of the collection definition, specifying a field's name, data type, and indexing behavior.

## Property parameters

| Parameter             | Type    | Description                                                                                                                                                                     | Default    |
| :-------------------- | :------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :--------- |
| `name`                | String  | The name of the property. See the [name](#name) section below for details.                                                                                                      | (Required) |
| `dataType`            | Array   | An array containing one or more data types. See [Data Types](../datatypes.md) for a full list. For cross-references, use the capitalized collection name (e.g., `["Article"]`). | (Required) |
| `description`         | String  | A description of the property for your reference.                                                                                                                               | `null`     |
| `tokenization`        | String  | For `text` properties, specifies how the text is split into tokens for inverted indexing. See the [tokenization](#tokenization) section below for details.                      | `word`     |
| `indexFilterable`     | Boolean | If `true`, builds a roaring bitmap index for this property to allow for efficient filtering. See [References: Inverted index](../indexing/inverted-index.mdx) for details.      | `true`     |
| `indexSearchable`     | Boolean | If `true`, builds a searchable map index for this property, suitable for BM25 or hybrid search. See [References: Inverted index](../indexing/inverted-index.mdx) for details.   | `true`     |
| `moduleConfig`        | Object  | Module-specific settings, such as skipping vectorization for this property. See [References: Vector index](../indexing/vector-index.mdx) for details.                           | `{}`       |
| `invertedIndexConfig` | Object  | Property-level overrides for inverted index settings, such as `bm25` parameters. See [References: Inverted index](../indexing/inverted-index.mdx) for details.                  | `{}`       |

<details>
  <summary>Example property configuration</summary>

An example of a complete property object:

```json
{
  "name": "title", // The name of the property
  "description": "title of the article", // A description for your reference
  "dataType": [
    // The data type of the object as described above. When creating cross-references, a property can have multiple dataTypes.
    "text"
  ],
  "tokenization": "word", // Split field contents into word-tokens when indexing into the inverted index. See "Property Tokenization" below for more detail.
  "moduleConfig": {
    // Module-specific settings
    "text2vec-contextionary": {
      "skip": true, // If true, the whole property is NOT included in vectorization. Default is false, meaning that the object will be NOT be skipped.
      "vectorizePropertyName": true // Whether the name of the property is used in the calculation for the vector position of data objects. Default false.
    }
  },
  "indexFilterable": true, // Optional, default is true. By default each property is indexed with a roaring bitmap index where available for efficient filtering.
  "indexSearchable": true // Optional, default is true. By default each property is indexed with a searchable index for BM25-suitable Map index for BM25 or hybrid searching.
}
```

</details>

### `name`

Property names can contain the following characters: `/[_A-Za-z][_0-9A-Za-z]*/`.

#### Reserved words

The following words are reserved and cannot be used as property names:

- `_additional`
- `id`
- `_id`

Additionally, we strongly recommend that you do not use the following words as property names, due to potential conflicts with future reserved words:

- `vector`
- `_vector`

### `tokenization`

:::note
This feature was introduced in `v1.12.0`.
:::

You can customize how `text` data is tokenized and indexed in the inverted index. Tokenization influences the results returned by the [`bm25`](../../api/graphql/search-operators.md#bm25) and [`hybrid`](../../api/graphql/search-operators.md#hybrid) operators, and [`where` filters](../../api/graphql/filters.md).

Tokenization is a property-level configuration for `text` properties. [See how to set the tokenization option using a client library](../../manage-collections/vector-config.mdx#property-level-settings)

<details>
  <summary>Example property configuration</summary>

```json
{
  "classes": [
    {
      "class": "Question",
      "properties": [
        {
          "dataType": ["text"],
          "name": "question",
          // highlight-start
          "tokenization": "word"
          // highlight-end
        },
      ],
      ...
      "vectorizer": "text2vec-openai"
    }
  ]
}
```

</details>

Each token will be indexed separately in the inverted index. For example, if you have a `text` property with the value `Hello, (beautiful) world`, the following table shows how the tokens would be indexed for each tokenization method:

import TokenizationDefinition from "/_includes/tokenization_definition.mdx";

<TokenizationDefinition />

#### Tokenization and search / filtering

Tokenization impacts how filters or keywords searches behave. The filter or keyword search query is also tokenized before being matched against the inverted index.

The following table shows an example scenario showing whether a filter or keyword search would identify a `text` property with value `Hello, (beautiful) world` as a hit.

- **Row**: Various tokenization methods.
- **Column**: Various search strings.

|                  | `Beautiful` | `(Beautiful)` | `(beautiful)` | `Hello, (beautiful) world` |
| ---------------- | ----------- | ------------- | ------------- | -------------------------- |
| `word` (default) | ✅          | ✅            | ✅            | ✅                         |
| `lowercase`      | ❌          | ✅            | ✅            | ✅                         |
| `whitespace`     | ❌          | ❌            | ✅            | ✅                         |
| `field`          | ❌          | ❌            | ❌            | ✅                         |

#### `gse` and `trigram` tokenization methods

:::info Added in `1.24`
:::

For Japanese and Chinese text, we recommend use of `gse` or `trigram` tokenization methods. These methods work better with these languages than the other methods as these languages are not easily able to be tokenized using whitespaces.

The `gse` tokenizer is not loaded by default to save resources. To use it, set the environment variable `ENABLE_TOKENIZER_GSE` to `true` on the Weaviate instance.

`gse` tokenization examples:

- `"素早い茶色の狐が怠けた犬を飛び越えた"`: `["素早", "素早い", "早い", "茶色", "の", "狐", "が", "怠け", "けた", "犬", "を", "飛び", "飛び越え", "越え", "た", "素早い茶色の狐が怠けた犬を飛び越えた"]`
- `"すばやいちゃいろのきつねがなまけたいぬをとびこえた"`: `["すばや", "すばやい", "やい", "いち", "ちゃ", "ちゃい", "ちゃいろ", "いろ", "のき", "きつ", "きつね", "つね", "ねが", "がな", "なま", "なまけ", "まけ", "けた", "けたい", "たい", "いぬ", "を", "とび", "とびこえ", "こえ", "た", "すばやいちゃいろのきつねがなまけたいぬをとびこえた"]`

#### `kagome_ja` tokenization method

:::caution Experimental feature
Available starting in `v1.28.0`. This is an experimental feature. Use with caution.
:::

For Japanese text, `kagome_ja` tokenization method is also available. This uses the [`Kagome` tokenizer](https://github.com/ikawaha/kagome?tab=readme-ov-file) with a Japanese [MeCab IPA](https://github.com/ikawaha/kagome-dict/) dictionary to split the property text.

The `kagome_ja` tokenizer is not loaded by default to save resources. To use it, set the environment variable `ENABLE_TOKENIZER_KAGOME_JA` to `true` on the Weaviate instance.

`kagome_ja` tokenization examples:

- `"春の夜の夢はうつつよりもかなしき 夏の夜の夢はうつつに似たり 秋の夜の夢はうつつを超え 冬の夜の夢は心に響く 山のあなたに小さな村が見える 川の音が静かに耳に届く 風が木々を通り抜ける音 星空の下、すべてが平和である"`:
  - [`"春", "の", "夜", "の", "夢", "は", "うつつ", "より", "も", "かなしき", "\n\t", "夏", "の", "夜", "の", "夢", "は", "うつつ", "に", "似", "たり", "\n\t", "秋", "の", "夜", "の", "夢", "は", "うつつ", "を", "超え", "\n\t", "冬", "の", "夜", "の", "夢", "は", "心", "に", "響く", "\n\n\t", "山", "の", "あなた", "に", "小さな", "村", "が", "見える", "\n\t", "川", "の", "音", "が", "静か", "に", "耳", "に", "届く", "\n\t", "風", "が", "木々", "を", "通り抜ける", "音", "\n\t", "星空", "の", "下", "、", "すべて", "が", "平和", "で", "ある"`]
- `"素早い茶色の狐が怠けた犬を飛び越えた"`:
  - `["素早い", "茶色", "の", "狐", "が", "怠け", "た", "犬", "を", "飛び越え", "た"]`
- `"すばやいちゃいろのきつねがなまけたいぬをとびこえた"`:
  - `["すばやい", "ちゃ", "いろ", "の", "きつね", "が", "なまけ", "た", "いぬ", "を", "とびこえ", "た"]`

#### `kagome_kr` tokenization method

:::caution Experimental feature
Available starting in `v1.25.7`. This is an experimental feature. Use with caution.
:::

For Korean text, we recommend use of the `kagome_kr` tokenization method. This uses the [`Kagome` tokenizer](https://github.com/ikawaha/kagome?tab=readme-ov-file) with a Korean MeCab ([mecab-ko-dic](https://bitbucket.org/eunjeon/mecab-ko-dic/src/master/)) dictionary to split the property text.

The `kagome_kr` tokenizer is not loaded by default to save resources. To use it, set the environment variable `ENABLE_TOKENIZER_KAGOME_KR` to `true` on the Weaviate instance.

`kagome_kr` tokenization examples:

- `"아버지가방에들어가신다"`:
  - `["아버지", "가", "방", "에", "들어가", "신다"]`
- `"아버지가 방에 들어가신다"`:
  - `["아버지", "가", "방", "에", "들어가", "신다"]`
- `"결정하겠다"`:
  - `["결정", "하", "겠", "다"]`

#### Limit the number of `gse` and `Kagome` tokenizers

The `gse` and `Kagome` tokenizers can be resource intensive and affect Weaviate's performance.
You can limit the combined number of `gse` and `Kagome` tokenizers running at the same time using the [`TOKENIZER_CONCURRENCY_COUNT` environment variable](/deploy/configuration/env-vars/index.md).

## Adding a property after collection creation

Adding a property after importing objects can lead to limitations in inverted-index related behavior, such as filtering by the new property's length or null status.

This is caused by the inverted index being built at import time. If you add a property after importing objects, the inverted index for metadata such as the length or the null status will not be updated to include the new properties. This means that the new property will not be indexed for existing objects. This can lead to unexpected behavior when querying.

To avoid this, you can either:

- Add the property before importing objects.
- Delete the collection, re-create it with the new property and then re-import the data.

We are working on a re-indexing API to allow you to re-index the data after adding a property. This will be available in a future release.

## Further resources

- [Starter guide: Collection definitions (schemas)](/weaviate/starter-guides/managing-collections)
- [How-to: Collection operations](../../manage-collections/collection-operations.mdx)
- [Concepts: Data structure](/weaviate/concepts/data)

## Questions and feedback

import DocsFeedback from "/_includes/docs-feedback.mdx";

<DocsFeedback />
